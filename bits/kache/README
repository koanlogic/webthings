Contents

  1 Requirements
  2 Kache Initialization
  3 Kache API
  4 Kache Supervisor API
  5 Kache Stats


1 Requirements
  Kache requires libu and makl to compile.


2 Kache Initialization

  kache_t *kache = kache_init();

  Kache stores pointers to generic objects. Kache maximum size is bounded, 
  and cached items are discarded with LFU policy.
  To let kache deallocate items correctly, the user must
  provide a free function for their object type.
  
  void kache_set_freefunc(kache_t *kache, void (*k_free)(void *obj));

  int kache_set_max_size(kache_t *kache, int max_size);

  void kache_free(kache_t *kache);

3 Kache API


  int kache_set(kache_t *kache, const char *key, const void *content);
  int kache_unset(kache_t *kache, const char *key);
  void *kache_get(kache_t *kache, const char *key);


4 Kache Supervisor API

  TBD

5 Kache Stats

  Kache stores the number of cache requests performed on every entry. 
  Every time an entry is updated, the number of gets performed on the key is 
  kept in a history.
  This data structure is useful to gather information about which cache 
  entries are more popular.
  Each history is associated to its kache entry.
  Kache entries can be accessed by iterating over them using this function:

  int kache_foreach_arg(kache_t *kache, 
                        int f(const void *kache_entry, const void *arg), 
                        const void *arg);

  The supplied function should return 0 in case of success and -1 in case 
  of failure.

  Kache history data are stored in this form:

  struct kache_history_record{
    struct timeval *insert_time; //request timestamp
    int access_counter;
    ...
  }


  Kache provides a simple macro to iterate over the history of an entry:

  kache_history_records_t req;

  KACHE_HISTORY_FOREACH(&req,kache_entry)
  {
      ...
  }
  The maximum size of an entry history defaults to 5. This can be changed with:

  int kache_set_history_length(kache_t *kache, int history_length)


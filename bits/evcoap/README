
1 Client

  Clients do requests and wait for corresponding responses.  Requests and
  responses are paired through CoAP tokens.  The client generates a token and
  adds it to the request using the Token option.  The server must mirror the 
  same Token option that was received by the client in the corresponding 
  response.

  Evcoap takes care of the CONfirmable semantics transparently.

1.1 Create Request

  A new request PDUs is created by specifying a method, an URI and the 
  underlying messaging model (i.e. CONfirmable or NON-confirmable):

      const char *uri = "coap://[::1]:56565/a/b/res";

      req = evcoap_new_request(EVCOAP_NON, EVCOAP_GET, uri);

  If the request needs to pass through a CoAP intermediary, then its address
  must be explicitly supplied through the following extended creation interface:

      const char *proxy = "kink.things.home.";
      ev_uint16_t port = 6565;

      pdu = evcoap_new_proxy_request(EVCOAP_CON, EVCOAP_PUT, uri, proxy, port);

  At present NoSec is the only mode supported, so URIs in the 'coaps' schema
  are rejected.  DTLS support is planned and will be implemented ASAP.


1.2 Customize Request

  Additional options (aside from Uri-* or Proxy-Uri and a default generated
  Token) may be added like this:

      const ev_uint8_t etag[] = { 0xde, 0xad, 0xbe, 0xef };

      evcoap_add_ifmatch_option(pdu, etag, sizeof etag);
      evcoap_add_accept_option(pdu, EVCOAP_CT_TEXT_PLAIN);

1.3 Send Request

  When sending a request PDU, the user wants to be notified when any event
  related to her request happens.  To achieve that, she will supply a callback
  (and args) to the send_request interface.  The callback will be invoked 
  whenever an interesting event related to the ongoing request happens -- namely
  a RST condition, or the response coming back (note that ACKs are managed 
  transparently.)

  The user may also supply a custom request timeout, so that she won't 
  starve waiting for a response that never comes back, e.g. due to a crashed
  or nonexistent server, a routing problem, etc.

      void cb(struct evcoap *coap, struct evcoap_pdu *res, 
              evcoap_send_status_t status, void *args) { ... }

      struct timeval tout = { .tv_sec = 5, .tv_usec = 125 };

      evcoap_send_request(coap, req, cb, NULL, &tout);
                            ^    ^    ^   ^      ^
                            |    |    |   |      |
                            |    |    |   |      `-- User timeout (may be NULL)
                            |    |    `---`-- User callback and args 
                            |    `-- Request PDU
                            `-- CoAP event base

  The CoAP event base is supplied as an auto parameter to the callback so that
  the user may break the event loop or otherwise manipulate it (e.g. add/remove
  her events, etc.), like in the following snippet:
 
      void cb (struct evcoap *coap, struct evcoap_pdu *res,
              evcoap_send_status_t status, void *args)
      {
          /* On error break the event loop. */
          if (status != EVCOAP_SEND_STATUS_OK)
               evcoap_loopbreak(coap);
          [...]
      }
     

2 Server

  Servers receive requests from clients and to their best to reply something 
  meaningful.

2.1 Configure Listening Address

  First off, a CoAP server binds one or more addresses:

      evcoap_bind_socket(coap, "127.0.0.1", 50505, 0)
      evcoap_bind_socket(coap, "[::1]", COAP_DEFAULT_PORT, 0)

  The underlying sockets will be automatically monitored for incoming PDUs.

  When a new request PDU comes in through one of the configured server 
  endpoints, an user-defined callback will be possibly triggered (see next
  paragraph.)


2.2 Register per-URI callbacks

  A CoAP server hosts resources identified by their URIs.

  The evcoap user supplies an URI path pattern (in fnmatch(3) format) and pair 
  it along with the callback function that she wants to be invoked whenever a 
  client requests an URI matching the pattern:

      evcoap_set_cb(coap, "/.well-known/*", cb, cb_args, NULL); 

  An optional timeout can be provided for cases where the server is not 
  replying immediately (i.e. within the invoked callback scope):

      evcoap_set_cb(coap, "/.well-known/*", cb, cb_args,
              &(struct timeval){.tv_sec = 5, .tv_usec = 0});

  When the timeout expires, if the user hasn't yet replied a request that came
  in with CON semantics, evcoap will automatically generate an ACK message for 
  the client.

  The callback function shall have the following signature:

    void cb(struct evcoap *coap, struct evcoap_pdu *req, void *args) { ... }

  Besides URI specific callbacks, the user can define a catch-all callback
  using:

      evcoap_set_gencb(coap, gen_cb, gen_cb_args)

  If this has been set, any request with an unmapped URI will trigger it, giving
  the user the opportunity to reply something more interesting than a generic
  4.04 (Not Found) response code.

Contents

  1 Library Initialization
  2 Client
  2.1 Create Request
  2.2 Customize Request
  2.3 Send Request
  3 Server
  3.1 Configure Listening Address
  3.2 Register per-URI callbacks
  3.3 Reply
  4. Observe
  5. PDUs Lifetime

1 Library Initialization

  The event handling machinery of evcoap is based on libevent 2.
  
  The evcoap event base, which has to be supplied to most of the high level 
  APIs, needs both a basic event base and a DNS event base, and is initialized
  like this:

      coap = ec_init(event_base_new(), evdns_base_new());

2 Client

  Clients do requests and wait for corresponding responses.  Requests and
  responses are paired through CoAP tokens.  The client generates a token and
  adds it to the request using the Token option.  The server must mirror the 
  same Token option that was received by the client in the corresponding 
  response.

  Evcoap takes care of timeout/retransmission logics of the CONfirmable message
  model transparently.

2.1 Create Request

  The most simple request PDU is created by specifying a method, an URI and
  a messaging model (confirmable or non-confirmable):

      ec_client_t *cli;
      const char *uri = "coap://[::1]:56565/a/b/res";

      cli = ec_request_new(EC_GET, uri, EC_NON);

  If the request needs to pass through a CoAP intermediary, then its address
  must be explicitly supplied through the following extended creation interface:

      const char *proxy = "kink.things.home.";
      ev_uint16_t port = 6565;

      cli = ec_proxy_request_new(EC_PUT, uri, EC_NON, proxy, port);

  At present NoSec is the only mode supported, so URIs in the 'coaps' schema
  are rejected.  DTLS support is planned and will be implemented ASAP.

2.2 Customize Request

  Additional options (aside from Uri-* or Proxy-Uri and a default generated
  Token, implicitly created by ec_new_request) may be added like this:

      const ev_uint8_t etag[] = { 0xde, 0xad, 0xbe, 0xef };

      ec_request_add_if_match(cli, etag, sizeof etag);
      ec_request_add_accept(cli, EC_MT_TEXT_PLAIN);
      ec_request_add_accept(cli, EC_MT_APPLICATION_JSON);

  If needed (e.g. when using PUT or POST methods) a payload may be added
  through:

      const ev_uint8_t payload[] = { 0xca, 0xfe, 0xba, 0xbe };

      ec_add_payload(req, payload, sizeof payload);

2.3 Send Request

  When sending a request PDU, the user wants to be notified when any event
  related to her request happens.  To achieve that, she will supply a callback
  (and args) to the send_request interface.  The callback will be invoked 
  whenever an interesting event related to the ongoing request happens -- namely
  a RST condition, or the response coming back (note that ACKs are managed 
  transparently.)

  The user may also supply a custom request timeout, so that she won't 
  starve waiting for a response that never comes back, e.g. due to a crashed
  or nonexistent server, a routing problem, etc.
  [[TBD: this may also be used as a "gather period" when the requested resource
  is multicast.  Multicast support needs some tweaking with the PDU format, 
  i.e. to support chaining of multiple responses.]]  

  The messaging model, be it CONfirmable or NON-confirmable, shall be conveyed
  in this step.

      void cb(ec_t *coap, ec_pdu_t *res, ec_send_status_t status, void *args) 
      { ... }

      struct timeval tout = { .tv_sec = 5, .tv_usec = 125 };

      ec_send_request(coap, req, EVCOAP_NON, cb, NULL, &tout);
                            ^    ^   ^           ^   ^      ^
                            |    |   |           |   |      |
                            |    |   |           |   |      `-- User timeout
                            |    |   |           `---`-- User callback and args 
                            |    |   `-- messaging model
                            |    `-- Request PDU
                            `-- CoAP event base

  The CoAP event base is supplied as an auto parameter to the callback so that
  the user may break the event loop or otherwise manipulate it (e.g. add/remove
  her events, etc.), like in the following snippet:
 
      void cb (ec_t *coap, ec_pdu_t *res, ec_send_status_t status, void *args)
      {
          /* On error break the event loop. */
          if (status != EVCOAP_SEND_STATUS_OK)
               ec_loopbreak(coap);
          [...]
      }

3 Server

  Servers receive requests from clients and to their best to reply something 
  meaningful.

3.1 Configure Listening Address

  First off, a CoAP server binds one or more addresses:

      ec_bind_socket(coap, "127.0.0.1", 50505)
      ec_bind_socket(coap, "[::1]", EVCOAP_DEFAULT_PORT)

  The underlying sockets will be automatically monitored for incoming PDUs.

  When a new (valid, non-duplicate) request PDU comes in through one of the 
  configured server endpoints, an user-defined callback will be possibly 
  triggered (see next paragraph.)

3.2 Register per-URI callbacks

  A CoAP server hosts resources identified by their URIs.

  The evcoap user supplies an URI path pattern (in fnmatch(3) format) and pair 
  it along with the callback function that she wants to be invoked whenever a 
  client requests an URI matching the pattern.  Also, the observe argument
  shall be set to true if the resource supports CoAP Observations (see 4), false
  otherwise:

      ev_uint8_t observable = 0;

      ec_set_cb(coap, "/.well-known/*", cb, cb_args, observable);

  The callback function shall have the following signature:

    int cb(ec_t *coap, ec_pdu_t *req, ec_pdu_t *res, void *args, 
            ev_uint8_t resched, struct timeval *resched_after) { ... }

  which is quite rich and needs some explanation.  First argument is an handler
  to the evcoap instance that may be used, if needed, as suggested in 2.3; 2nd
  is the received request PDU; 3rd is a preallocated PDU that will possibly hold
  the user generated response; 4th is the optional arguments that the user has
  supplied when installing this callback.

  The 'resched' and 'resched_to' arguments are needed for handling the scenario
  where the CON messaging model is in use, and the CoAP server isn't able to
  immediately produce the response (e.g. because producing the resource
  representation takes some time and you don't want to block the whole I/O
  machinery in the meanwhile.)

  In cases as such, CoAP provides a "separated ACK" strategy that lets the
  client know that the response has been taken in charge, and a response will
  follow as a separate CON message as soon as possible.  The 'resched' parameter
  is filled by the user to tell evcoap to re-schedule the callback after the
  supplied time has passed.  The 'resched' argument is a boolean that 
  distinguishes an invocation due to a newly received request (resched=false),
  from a "rescheduled" invocation (resched=true.)

  The return code of the callback is '0' in case a reponse has been produced
  (even if it  holds an error response code) and !0 otherwise, in which case
  evcoap will automatically send a 5.00 Internal Server Error, message back
  to the client.

  For an example of reschedulable callback, see the following:

    int lengthy_cb(ec_t *coap, ec_pdu_t *req, ec_pdu_t *res, void *args, 
            ev_uint8_t resched, struct timeval *resched_after)
    {
        if (!resched)
        {
            /* Request the creation of the resource representation
             * and ask evcoap to be called back in 1 second. */
            ask_resource_creation();
            *resched_after = { .tv_sec = 1, .tv_usec = 0 };
            return 0;
        } 
        else
        {
            /* Check if the resource has been produced. */
            if (r = lengthy_resource_is_ready(&rlen))
            {
                ec_add_payload(res, r, rlen);
                ec_set_response_code(res, EVCOAP_205);
                return 0;
            }
            else
            {
                /* Nope, call me back in 0.5 seconds we should be
                 * luckier this time. */
                *resched_after = { .tv_sec = 0, .tv_usec = 5 };
                return 0;
            }
        }
    }
  
  If the user is able to produce an immediate representation for the resource,
  or if she don't mind blocking (though this is generally discouraged when using
  evcoap) the 'state' and 'resched' arguments can be safely ignored.


  Besides URI specific callbacks, the user can define a catch-all callback
  using:

      ec_set_gencb(coap, gen_cb, gen_cb_args)

  If this has been set, any request with an unmapped URI will trigger it, giving
  the user the opportunity to reply something more interesting than a generic
  4.04 (Not Found) response code.

3.3 Reply

  As already showed in 3.2, a response PDU is created by evcoap automatically 
  and supplied as the third argument to the callback.  Allocation/deallocation
  are handled transparently so that the user doesn't need to take care of it.

  A mandatory (except when using a separate ACK) response code is set with:

      ec_set_response_code(res, EVCOAP_205);
  
  Payload and options may be added to the response PDU, using the same interface
  as in section 2.2.

  There is no interface for sending responses: evcoap will handle the needed
  steps when the user callback returns with a valid response PDU.

4. Observe

  An observable resource shall update its state using the following interface:

       int ec_update_representation(const char *uri, const ev_uint8_t *rep, 
               size_t rep_len, ec_mt_t media_type);

  [[TODO]]

5. PDUs Lifetime

   Evcoap always owns both request and response PDUs so that the user never has
   to worry about deallocation, with the only exception of the request PDUs in 
   Client mode, whose ownership is user's until it is supplied to the send 
   interface.  E.g.:

      req = ec_new_request(EVCOAP_GET, uri);

      if (some abnormal condition happens)
          goto err;

      ec_send_request(coap, req, EVCOAP_NON, cb, NULL, &tout);
      req = NULL; /* After sending, drop ownership. */

      [...]

   err:
      if (req)
          ec_delete_request(req);
      return -1;
